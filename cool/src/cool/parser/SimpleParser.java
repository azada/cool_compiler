package cool.parser;

import java.util.ArrayList;
import beaver.*;
import cool.parser.ast.*;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "cool.grammar".
 */
public class SimpleParser extends Parser {

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pTM0buLSKL$kU#zmA9WY880YO10XWZ3H28G03P4mBkg6sAMhVQrWMgRQNKjLQfkr8NjAZ" +
		"5kXPHDWM2o2RA$d31aDRMhHLjtS7Tsl6VkUTkxzqa8FXLlVET#S#SETkScNllkm$8cQgNPp" +
		"Mj$#To68$JqHu$mSdeh3$7d427CmUWFRb$U0td2BRHQU42wv$fD783NOwgK4EDFN0GIj53$" +
		"nL7uL3q8jw9Ot4YZi3UE1x7uVluWU#b2CtH0HCv7Y1UZ#Ie6GenLx$YjxIB689MmhdstVHw" +
		"Hgt4RO4k1cCoMY17F#qr$4Pm4dubtFMeei$rs0TtCDEH8Tt3QTs6t2QlqTh5IVYrS6xiKt4" +
		"OOxTcx41tF7x8#ctIBtWDGmL7er8u6nkZqD767XFI7OyJQFs2$hlVqYvotPN2ZSUF6Nii9k" +
		"XQtArh0rsSXRCnczpVl8Pp1H$MwqHMgpVGBfz#Qt4V#q3tAkPKGoxDlJkGCscxTqDmZrwNk" +
		"NTwCThg3RWExSpUwPUynhgvN1hNYcI6NgGN6iAVCKK$4kZgVtiD9OBVGvd8n4OlbTxNrV$n" +
		"6leAbkDWuQhq0lJJ2$GoLlMFUfb8Yr6Xt$3R4i7dCL2u1RYNDezpnUnnI4XtgzSmJ72GVav" +
		"aI$1xpDIpSGL6wDdwcK1Nl#urL0ltB8OBzv2UenzsUunZjNnT$PhNS9BWZ$GNmat5$NerRi" +
		"83UhN#BtuUwEf$UGs$4FmbpXFPatgDVahwnt1#eAl$wJLS87WXBXVPMbo4Yt6fdezBz3nS6" +
		"UZgL$qsrqLSXQk5km7Nu0#qlH6tu6RSAj9Yzi5TELtmTlseS7$Igz06T#cLUeL#WjKCxlQN" +
		"lOQ$23w8MS8zX7cOZqLu18#Y5Wj4Mip#HQzXeU1YF2RS4Yp5urY1PLYEbNWYqDLlUGsh19$" +
		"2ayAjnXginNgimmPin2QH5lDyf$4q#sVn33RRUwKEp#cDXWitF8yQ05jma8pD7ULUcKz3w2" +
		"r6pDuy3VleBUxOIAADadehhnT9lJksaaYZ96tbQP6atR6LHFE4hhFoEf7KkMChYRIGJrVIi" +
		"CzZxDgn8sltB$CqUTDhz2aOviANI8j3JmLu6EOYDjvJGR8JSPFPSGKckz1gBNDPTYq32pjE" +
		"XTvh4x0NtsjEAFPPI3GIkmP9My5PzbGqfkVv#tRh1PUfzRjUOoq5mvozl3FsBhhZj1ts$8x" +
		"Nw4ymp8KlIkXPl#qrIWJ3N2INjvl8PUUhPgu6zVJx#dsSOdkOtc2OY$ZfkklnThUUVa#$n$" +
		"nD3zCR37F$j$p3T#wPziuzGt#WFs1kVczGnbqGNFj6R65jU#fjUXjr$TwWZ6chj#ljw6rxo" +
		"niKQPSORx#BaUqPok2tCVCjOsJxnSWAz4Vw8yRsUuEyEk6dCThzOsH7nyYcHNxX0tcKHINx" +
		"er1$fZzZJBzd#qH$GjxlsJxLdvBtUxQFzSVa$PxjG$qXURzdswmta$TxWr1y5YVuZ4qXXry" +
		"SpUqgzs0TM$3zS21AU4Pwy5Sf#7koBN$hxiTSEyXCGSXwi5Zdqa#STMx8slXoQAsesmTzQP" +
		"$BIXZx8kxFNZnzhVXDqfg$Y$ODUUd8sdIDUEsAdkZ5RxKWYuHaqOnnebcaE5VAFiYYdEFca" +
		"JKSBDOL62ZM#TGfP5PvF7ycqy2wZ3EvJLXxiKTplYmIExj#UMBTadx3iSiP9JDsjdMmxj98" +
		"RBF6p7NtusajZLWV8jO3$BtBvsmXvnLZZwH6O9rdhGhiUScZTShkNJFssNkNe6vNnahQlGl" +
		"YvKgy8WoIU9qeDxvIwCRlsCB8MV6ioiJAhDNBCf#wXJRBBf4ii#lQcJ5SArEH0aPIjghnLX" +
		"2h70ptOoaRAMaZ9MAjEekLEMkkLLVEvLkhxWrQTVVNvMMeR4lQfZBkdCngTFBlrW9hrTbQc" +
		"UTKdDMGh0p3iH8DLDwhuL3cubgbR3rps0f8WngjHXuvrogFDjsuwyRAMCTP9VpA5ufLjJrZ" +
		"PVPqf5ZDEAi1MR4wiVP5F8$vtA#M3QohcrZjpTwrwi1HHqRRdwTOHUwQx0oJVYnJW#xKRK#" +
		"DTfHvLWxxFUbb7xjsSv#qiVkLUP#qXgErVL#Q#oJVQ6fxPMfIubZvTqRJL7L7VNfNz6d2iT" +
		"qFEsFtGsTS$dvy5Hl9JgHDPaV$9hiCVPwqnbUJ7tclbThtMkyWjdrcDrn31rMsWcEihqRqV" +
		"7$VQhsTFmd#6NDtzUixOxinbvslMlZ4nUWraLlO3tFRzNYxM##Rcd$SdSjSgTd4oS6ei2t7" +
		"Es1hgp0YVZRMMumibC6m7RNPoKntnMksB5kI5VbhbTHVudvFLjZl6FFL1kuyS0gGsC2VYkF" +
		"TB#d4oyJ1HFCzF0b8qZRdDDBP78yZNKcwsNwNGl5PeKfTjqa#QTJ9P6QGrd3CzQaMn96qFO" +
		"$4t#h9zK3gGU9B97xFfH94sgJQ0SvDr6S#YZkYoZcUHJoEnEz9PmLz3Y7MSNmCyKtYwIJce" +
		"uubdK0$vn2PcpgJT2$ZNKmRvgrk9Ny5#SNaBoVTHxgEwpD9Swtg0T9yZdblgkd44g9Poqhx" +
		"zG0i8xr8#e9vhkKyyr2RI5D8Tv6MaBQGjZ4lhZV56Zh5f17aJSudScuvYJLn9bF6V5EdCb$" +
		"ca69z4yUJM9$a$HnVJQgdxWMaMnYp3$4LabalzqXrXFdV18fVyShyHt0kaT$EYdQOG$zSb6" +
		"9yzGPvxflJalpd9ERkE8p3c8vvlhz3v2y9X$wKqPbDdluSVeMgkSHM9Ew9udhLEXBtpUb1N" +
		"4riJUfBVXYHTNBubPLSIEn7sN36O7sTKQHAZha#X#T35H4F8uqXcVqyYdGqvTnpJ2I#Hc9#" +
		"pa3YLYBtqwaY7MeECf5gZYAr9LMJnfAuzyuH97CUQaWdaRZV3clYi7uEpwipWSHZxp26Spw" +
		"9PzQvXiHpuh2#peMasqYNaUuWNKIwbdGzYMV8cKgQHhgJT0$9h8tds#6PScQIJDtk9fdQrx" +
		"htL#9sWs7YrIlWSpgxc5eZM1#ZVwdCJGvagLUZEZab8d$Ba$6njLNiYmL7YtnxOAUAPAv5o" +
		"FUqp1ooSyf9X7mS7lOVhs#UAvWU8vz1MYpy6J5nMcJACknl3F7pGZdD3Ccd2AxAi4rbZ5U6" +
		"nwpJwyQ6lXR9$94XtOdPkQYww3YrD4OdNBUjZQsjuJNdj0lv69izxpGNx9AnleqPUYLV9Vu" +
		"tXUGQnoy4PQa$7mpzXU$D1tflOa##xNhoTsbFooVublL8yPTDWgJu1au8ARxn4aAAx#U4aE" +
		"4TGPKnDfYqUgEPpMZAIYWh8VObzg7S9VCBn$ppaa0vSofdJkMK5TEsc6ZUcbKuWDz4ARvj7" +
		"LA2f33IKiBY09X$jHoIGZMncbZ6kL74KO93Y0CvDv1y1T$h5VHNmNWLCF$bAKl3X8PIjv9O" +
		"AJY8EFPBepgb1G==");

	public SimpleParser() {
		super(PARSING_TABLES);
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch(rule_num) {
			case 1: // program = class_list.cl
			{
					final Symbol _symbol_cl = _symbols[offset + 1];
					final ArrayList cl = (ArrayList) _symbol_cl.value;
					 return new Symbol(cl);
			}
			case 2: // class_list = classdecl.cd class_list.cl
			{
					final Symbol cd = _symbols[offset + 1];
					final Symbol _symbol_cl = _symbols[offset + 2];
					final ArrayList cl = (ArrayList) _symbol_cl.value;
					 cl.add(cd); return new Symbol(cl);
			}
			case 3: // class_list = empty
			{
					 return new Symbol( new ArrayList() );
			}
			case 5: // expr = lexpr.le ASSIGN rexpr.re
			{
					final Symbol le = _symbols[offset + 1];
					final Symbol _symbol_re = _symbols[offset + 3];
					final Expr re = (Expr) _symbol_re.value;
					 ArrayList operands = new ArrayList(); operands.add(le); operands.add(re); return new AssignmentOperation(operands);
			}
			case 6: // expr = rexpr.r
			{
					final Symbol _symbol_r = _symbols[offset + 1];
					final Expr r = (Expr) _symbol_r.value;
					 return r;
			}
			case 7: // rexpr = IF LPAREN rexpr.cond RPAREN expr.m ELSE expr.e
			{
					final Symbol _symbol_cond = _symbols[offset + 3];
					final Expr cond = (Expr) _symbol_cond.value;
					final Symbol _symbol_m = _symbols[offset + 5];
					final Expr m = (Expr) _symbol_m.value;
					final Symbol _symbol_e = _symbols[offset + 7];
					final Expr e = (Expr) _symbol_e.value;
					 return new IfNode( cond, m, e);
			}
			case 8: // rexpr = WHILE LPAREN rexpr.cond RPAREN expr.e
			{
					final Symbol _symbol_cond = _symbols[offset + 3];
					final Expr cond = (Expr) _symbol_cond.value;
					final Symbol _symbol_e = _symbols[offset + 5];
					final Expr e = (Expr) _symbol_e.value;
					 return new WhileNode( cond, e);
			}
			case 9: // rexpr = rel.r
			{
					final Symbol r = _symbols[offset + 1];
					 return r;
			}
			case 10: // rexpr = primary.p MATCH cases.c
			{
					final Symbol p = _symbols[offset + 1];
					final Symbol _symbol_c = _symbols[offset + 3];
					final ArrayList c = (ArrayList) _symbol_c.value;
					 Expr e = (Expr) p.value; return new Match(e, c);
			}
			case 11: // rel = rel.r LE equiv.e
			{
					final Symbol r = _symbols[offset + 1];
					final Symbol e = _symbols[offset + 3];
					  ArrayList operands = new ArrayList(); operands.add(r); operands.add(e); return new LessOrEqual(operands);
			}
			case 12: // rel = rel.r LT equiv.e
			{
					final Symbol r = _symbols[offset + 1];
					final Symbol e = _symbols[offset + 3];
					  ArrayList operands = new ArrayList(); operands.add(r); operands.add(e); return new LessThan(operands);
			}
			case 13: // rel = equiv.e
			{
					final Symbol e = _symbols[offset + 1];
					 return e;
			}
			case 14: // equiv = equiv.e EQUALS sum.s
			{
					final Symbol e = _symbols[offset + 1];
					final Symbol s = _symbols[offset + 3];
					  ArrayList operands = new ArrayList(); operands.add(e); operands.add(s); return new Equal(operands);
			}
			case 15: // equiv = sum.s
			{
					final Symbol s = _symbols[offset + 1];
					 return s;
			}
			case 16: // sum = sum.s PLUS product.p
			{
					final Symbol s = _symbols[offset + 1];
					final Symbol p = _symbols[offset + 3];
					 ArrayList operands = new ArrayList(); operands.add(s); operands.add(p); return new PlusOperation(operands);
			}
			case 17: // sum = sum.s MINUS product.p
			{
					final Symbol s = _symbols[offset + 1];
					final Symbol p = _symbols[offset + 3];
					 ArrayList operands = new ArrayList(); operands.add(s); operands.add(p); return new MinusOperation(operands);
			}
			case 18: // sum = product.p
			{
					final Symbol p = _symbols[offset + 1];
					 return p;
			}
			case 19: // product = product.p TIMES primary.i
			{
					final Symbol p = _symbols[offset + 1];
					final Symbol i = _symbols[offset + 3];
					 ArrayList operands = new ArrayList(); operands.add(p); operands.add(i); return new MultiplyOperation(operands);
			}
			case 20: // product = product.p DIV primary.i
			{
					final Symbol p = _symbols[offset + 1];
					final Symbol i = _symbols[offset + 3];
					 ArrayList operands = new ArrayList(); operands.add(p); operands.add(i); return new DivisionOperation(operands);
			}
			case 21: // product = primary.p
			{
					final Symbol p = _symbols[offset + 1];
					 return p;
			}
			case 22: // primary = LBRACE block.b RBRACE
			{
					final Symbol _symbol_b = _symbols[offset + 2];
					final Block b = (Block) _symbol_b.value;
					 return (Expr)b;
			}
			case 23: // primary = LPAREN expr.e RPAREN
			{
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 24: // primary = NULL
			{
					 return new NullNode();
			}
			case 25: // primary = LPAREN RPAREN
			{
					 return new Unit();
			}
			case 26: // primary = INTEGER.i
			{
					final Symbol _symbol_i = _symbols[offset + 1];
					final String i = (String) _symbol_i.value;
					 return new IntegerNode(Integer.parseInt(i));
			}
			case 27: // primary = STRING.s
			{
					final Symbol _symbol_s = _symbols[offset + 1];
					final String s = (String) _symbol_s.value;
					 return new StringNode(s);
			}
			case 28: // primary = BOOLEAN.b
			{
					final Symbol _symbol_b = _symbols[offset + 1];
					final Boolean b = (Boolean) _symbol_b.value;
					 return new BooleanNode(b);
			}
			case 29: // primary = MINUS primary.p
			{
					final Symbol p = _symbols[offset + 2];
					 ArrayList operands = new ArrayList() ; operands.add(p); return new UnaryRealOperation(operands);
			}
			case 30: // primary = lexpr.e
			{
					final Symbol e = _symbols[offset + 1];
					 return e;
			}
			case 31: // primary = NOT primary.p
			{
					final Symbol p = _symbols[offset + 2];
					 ArrayList operands = new ArrayList() ; operands.add(p); return new UnaryBooleanOperation(operands);
			}
			case 32: // primary = primary DOT ID actuals.a
			{
					final Symbol _symbol_a = _symbols[offset + 4];
					final ArrayList a = (ArrayList) _symbol_a.value;
					 return new PrimaryActual(a);
			}
			case 33: // primary = NEW TYPE.t actuals.s
			{
					final Symbol _symbol_t = _symbols[offset + 2];
					final String t = (String) _symbol_t.value;
					final Symbol _symbol_s = _symbols[offset + 3];
					final ArrayList s = (ArrayList) _symbol_s.value;
					 return new Instance(t,s);
			}
			case 36: // ident = ID.id opt$actuals
			{
					final Symbol _symbol_id = _symbols[offset + 1];
					final String id = (String) _symbol_id.value;
					 return new Id(id);
			}
			case 37: // ident = THIS
			{
					 return new Id("this");
			}
			case 38: // block = st_list.el expr.e
			{
					final Symbol el = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 ArrayList es = (ArrayList) el.value; return new Block(es , e);
			}
			case 39: // st_list = st_list.el new_var.ve SEMI
			{
					final Symbol el = _symbols[offset + 1];
					final Symbol ve = _symbols[offset + 2];
					 ArrayList es = (ArrayList) el.value; es.add(ve); return new Symbol(es);
			}
			case 40: // st_list = st_list.el expr.e SEMI
			{
					final Symbol el = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 ArrayList es = (ArrayList) el.value; es.add(e); return new Symbol(es);
			}
			case 41: // st_list = empty
			{
					 ArrayList el  = new ArrayList(); return new Symbol(el);
			}
			case 42: // new_var = VAR ID.id COLON TYPE.t ASSIGN expr.e
			{
					final Symbol _symbol_id = _symbols[offset + 2];
					final String id = (String) _symbol_id.value;
					final Symbol _symbol_t = _symbols[offset + 4];
					final String t = (String) _symbol_t.value;
					final Symbol _symbol_e = _symbols[offset + 6];
					final Expr e = (Expr) _symbol_e.value;
					 return new VarExpr( id, t, e);
			}
			case 43: // cases = LBRACE case_block.cb RBRACE
			{
					final Symbol _symbol_cb = _symbols[offset + 2];
					final ArrayList cb = (ArrayList) _symbol_cb.value;
					 return new Symbol(cb);
			}
			case 44: // case_block = CASE ID.id COLON TYPE.t ARROW block.b case_block.cb
			{
					final Symbol _symbol_id = _symbols[offset + 2];
					final String id = (String) _symbol_id.value;
					final Symbol _symbol_t = _symbols[offset + 4];
					final String t = (String) _symbol_t.value;
					final Symbol _symbol_b = _symbols[offset + 6];
					final Block b = (Block) _symbol_b.value;
					final Symbol _symbol_cb = _symbols[offset + 7];
					final ArrayList cb = (ArrayList) _symbol_cb.value;
					 cb.add(new Case(id,t,b));return new Symbol(cb);
			}
			case 45: // case_block = CASE NULL ARROW block.b case_block.cb
			{
					final Symbol _symbol_b = _symbols[offset + 4];
					final Block b = (Block) _symbol_b.value;
					final Symbol _symbol_cb = _symbols[offset + 5];
					final ArrayList cb = (ArrayList) _symbol_cb.value;
					 cb.add(new Case(b));return new Symbol(cb);
			}
			case 46: // case_block = empty
			{
					 return new Symbol(new ArrayList());
			}
			case 47: // lexpr = SUPER DOT ID actuals.a
			{
					final Symbol _symbol_a = _symbols[offset + 4];
					final ArrayList a = (ArrayList) _symbol_a.value;
					 return new SuperActual(a);
			}
			case 48: // lexpr = ident.id
			{
					final Symbol _symbol_id = _symbols[offset + 1];
					final Id id = (Id) _symbol_id.value;
					 return id;
			}
			case 51: // classdecl = CLASS TYPE.t varformals.v have_extends.e classbody.fl
			{
					final Symbol _symbol_t = _symbols[offset + 2];
					final String t = (String) _symbol_t.value;
					final Symbol _symbol_v = _symbols[offset + 3];
					final ArrayList v = (ArrayList) _symbol_v.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Extends e = (Extends) _symbol_e.value;
					final Symbol fl = _symbols[offset + 5];
					 return new ClassNode(t, v, e, (ArrayList)fl.value);
			}
			case 52: // varformals = LPAREN RPAREN
			{
					 return new Symbol(new ArrayList());
			}
			case 53: // varformals = LPAREN var_list.vl RPAREN
			{
					final Symbol _symbol_vl = _symbols[offset + 2];
					final ArrayList vl = (ArrayList) _symbol_vl.value;
					 return new Symbol(vl);
			}
			case 54: // varformals = empty
			{
					 return new Symbol(new ArrayList());
			}
			case 55: // var_list = one_var.v
			{
					final Symbol _symbol_v = _symbols[offset + 1];
					final Var v = (Var) _symbol_v.value;
					 ArrayList vl = new ArrayList(); vl.add(v); return new Symbol(vl);
			}
			case 56: // var_list = var_list.vl COMMA one_var.v
			{
					final Symbol _symbol_vl = _symbols[offset + 1];
					final ArrayList vl = (ArrayList) _symbol_vl.value;
					final Symbol _symbol_v = _symbols[offset + 3];
					final Var v = (Var) _symbol_v.value;
					 vl.add(v); return new Symbol(vl);
			}
			case 57: // var_list = empty
			{
					 new Symbol( new ArrayList() );
			}
			case 58: // one_var = VAR ID.id COLON TYPE.t
			{
					final Symbol _symbol_id = _symbols[offset + 2];
					final String id = (String) _symbol_id.value;
					final Symbol _symbol_t = _symbols[offset + 4];
					final String t = (String) _symbol_t.value;
					 return new Var(id, t);
			}
			case 59: // have_extends = EXTENDS type_or_native.ext
			{
					final Symbol ext = _symbols[offset + 2];
					 return ext;
			}
			case 61: // type_or_native = TYPE.t actuals.a
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final String t = (String) _symbol_t.value;
					final Symbol _symbol_a = _symbols[offset + 2];
					final ArrayList a = (ArrayList) _symbol_a.value;
					 return new Extends(t, a);
			}
			case 62: // type_or_native = NATIVE
			{
					 return new Extends();
			}
			case 63: // actuals = LPAREN exp_list.el RPAREN
			{
					final Symbol _symbol_el = _symbols[offset + 2];
					final ArrayList el = (ArrayList) _symbol_el.value;
					 return new Symbol(el);
			}
			case 64: // exp_list = expr.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 ArrayList el = new ArrayList(); el.add(e); return new Symbol(el);
			}
			case 65: // exp_list = exp_list.el COMMA expr.e
			{
					final Symbol _symbol_el = _symbols[offset + 1];
					final ArrayList el = (ArrayList) _symbol_el.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					 el.add(e); return new Symbol(el);
			}
			case 66: // exp_list = empty
			{
					 return new Symbol( new ArrayList() );
			}
			case 67: // classbody = LBRACE feature_list.fl RBRACE
			{
					final Symbol _symbol_fl = _symbols[offset + 2];
					final ArrayList fl = (ArrayList) _symbol_fl.value;
					 return new Symbol(fl);
			}
			case 68: // feature_list = feature.f feature_list.fl
			{
					final Symbol _symbol_f = _symbols[offset + 1];
					final Feature f = (Feature) _symbol_f.value;
					final Symbol _symbol_fl = _symbols[offset + 2];
					final ArrayList fl = (ArrayList) _symbol_fl.value;
					 fl.add(f); return new Symbol(fl);
			}
			case 69: // feature_list = empty
			{
					 return new Symbol( new ArrayList() );
			}
			case 70: // feature = overridable DEF ID.id formals.fl COLON TYPE.t ASSIGN expr_or_native.e SEMI
			{
					final Symbol _symbol_id = _symbols[offset + 3];
					final String id = (String) _symbol_id.value;
					final Symbol fl = _symbols[offset + 4];
					final Symbol _symbol_t = _symbols[offset + 6];
					final String t = (String) _symbol_t.value;
					final Symbol e = _symbols[offset + 8];
					 return new FeatureMethod(id, (ArrayList)fl.value, t, (Expr)e);
			}
			case 71: // feature = VAR ID.id ASSIGN NATIVE SEMI
			{
					final Symbol _symbol_id = _symbols[offset + 2];
					final String id = (String) _symbol_id.value;
					 return new FeatureVar(id );
			}
			case 72: // feature = VAR ID.id COLON TYPE.t ASSIGN expr.e SEMI
			{
					final Symbol _symbol_id = _symbols[offset + 2];
					final String id = (String) _symbol_id.value;
					final Symbol _symbol_t = _symbols[offset + 4];
					final String t = (String) _symbol_t.value;
					final Symbol _symbol_e = _symbols[offset + 6];
					final Expr e = (Expr) _symbol_e.value;
					 return new FeatureVar(id, t, e );
			}
			case 73: // feature = LBRACE block.b RBRACE SEMI
			{
					final Symbol _symbol_b = _symbols[offset + 2];
					final Block b = (Block) _symbol_b.value;
					 return new FeatureBlock(b);
			}
			case 76: // expr_or_native = expr.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
			}
			case 78: // formals = LPAREN formal_list.fl RPAREN
			{
					final Symbol _symbol_fl = _symbols[offset + 2];
					final ArrayList fl = (ArrayList) _symbol_fl.value;
					 return new Symbol(fl);
			}
			case 79: // formal_list = formal.f
			{
					final Symbol _symbol_f = _symbols[offset + 1];
					final Formal f = (Formal) _symbol_f.value;
					 ArrayList fl = new ArrayList(); fl.add(f); return new Symbol(fl);
			}
			case 80: // formal_list = formal_list.fl COMMA formal.f
			{
					final Symbol _symbol_fl = _symbols[offset + 1];
					final ArrayList fl = (ArrayList) _symbol_fl.value;
					final Symbol _symbol_f = _symbols[offset + 3];
					final Formal f = (Formal) _symbol_f.value;
					 fl.add(f); return new Symbol(fl);
			}
			case 81: // formal_list = empty
			{
					 return new Symbol( new ArrayList() );
			}
			case 82: // formal = ID.id COLON TYPE.t
			{
					final Symbol _symbol_id = _symbols[offset + 1];
					final String id = (String) _symbol_id.value;
					final Symbol _symbol_t = _symbols[offset + 3];
					final String t = (String) _symbol_t.value;
					  return new Formal(id,t);
			}
			case 34: // opt$actuals = 
			case 49: // empty = 
			{
				return new Symbol(null);
			}
			case 0: // program = expr
			case 4: // program = bogus
			case 35: // opt$actuals = actuals
			case 60: // have_extends = empty
			case 74: // overridable = OVERRIDE
			case 75: // overridable = empty
			case 77: // expr_or_native = NATIVE
			{
				return _symbols[offset + 1];
			}
			case 50: // bogus = STUB CLASS EXTENDS VAR OVERRIDE DEF NATIVE NEW NULL THIS CASE MATCH IF ELSE WHILE SUPER LPAREN RPAREN LBRACE RBRACE COLON COMMA ASSIGN SEMI ARROW DOT PLUS MINUS TIMES DIV LE LT EQUALS NOT TYPE ID INTEGER STRING BOOLEAN
			{
				return _symbols[offset + 39];
			}
			default:
				throw new IllegalArgumentException("unknown production #" + rule_num);
		}
	}
}
